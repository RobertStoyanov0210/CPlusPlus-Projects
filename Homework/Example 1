#include <iostream>
#include <cassert>
using namespace std;

class RegTask {
public:
	RegTask(size_t = 0, int* = 0, double* = 0);
	RegTask(const RegTask &);
	~RegTask();
	RegTask& operator=(const RegTask &);
	void print()const;
	void newRegistry(int, double);
	double sumTotal() const;
	int maxLevelPaid() const;
	double searchLevel(int)const;
private:
	size_t n;
	int * level;
	double * paid;
};

int main() {
	RegTask x;
	for (size_t i = 0; i < 10; i++)
	{
		x.newRegistry(rand() % 10 + 1, (((double)rand() / RAND_MAX)*280. + 20));
	}
	x.print();
	cout << "Total sum: " << x.sumTotal() << endl;
	cout << "Max paid task: " << x.maxLevelPaid() << endl;

	int sz = 5;
	int level[] = { 1, 2, 3, 4, 5 };
	double paid[] = { 34.5, 44.5, 55.7, 78, 900 };

	RegTask y(sz, level, paid);
	y.print();
	cout << "Total sum: " << y.sumTotal() << endl;
	cout << "Max paid task: " << y.maxLevelPaid() << endl;

	int k;
	cout << "enter level: ";
	cin >> k;
	cout << "search for x: " << x.searchLevel(k) << endl;
	cout << "search for y: " << y.searchLevel(k) << endl;

	system("pause");
	return 0;
}

RegTask::RegTask(size_t sz, int* l, double* p) :
	n(sz), level(new int[n]), paid(new double[n]) {
	assert(level != NULL);
	assert(paid != NULL);
	for (size_t i = 0; i < n; i++)
	{
		level[i] = l[i];
		paid[i] = p[i];
	}
}

RegTask::RegTask(const RegTask & r) {
	n = r.n;
	level = new int[n];
	assert(level != NULL);
	paid = new double[n];
	assert(paid != NULL);
	for (size_t i = 0; i < n; i++)
	{
		level[i] = r.level[i];
		paid[i] = r.paid[i];
	}
}

RegTask::~RegTask() {
	delete[] paid;
	delete[] level;
}

RegTask& RegTask::operator=(const RegTask & r) {
	if (this != &r) {
		n = r.n;
		if (level != NULL) delete[] level;
		level = new int[n];
		assert(level != NULL);
		if (paid != NULL) delete[] paid;
		paid = new double[n];
		assert(paid != NULL);
		for (size_t i = 0; i < n; i++)
		{
			level[i] = r.level[i];
			paid[i] = r.paid[i];
		}
	}
	return *this;
}

void RegTask::print()const {
	std::cout << "Print data for the object\n";
	for (size_t i = 0; i < n; i++)
	{
		std::cout << "Level[" << level[i] << "] = " << paid[i]
			<< std::endl;
	}
}

void RegTask::newRegistry(int k, double p) {
	if (n == 0) {
		n = 1;
		level = new int[n];
		assert(level != NULL);
		level[0] = k;
		paid = new double[n];
		assert(paid != NULL);
		paid[0] = p;
	}
	else {
		n++;
		int * tmp_level = new int[n];
		double * tmp_paid = new double[n];
		for (size_t i = 0; i < n - 1; i++)
		{
			tmp_level[i] = level[i];
			tmp_paid[i] = paid[i];
		}
		tmp_level[n - 1] = k;
		tmp_paid[n - 1] = p;
		delete[] level;
		delete[] paid;
		level = tmp_level;
		paid = tmp_paid;
	}
}

double RegTask::sumTotal() const {
	double sum = 0.;
	for (size_t i = 0; i < n; i++)
	{
		sum += paid[i];
	}
	return sum;
}

int RegTask::maxLevelPaid() const {
	size_t ind = 0;
	double maxPaid = paid[0];
	for (size_t i = 1; i < n; i++)
	{
		if (maxPaid < paid[i]) {
			maxPaid = paid[i];
			ind = i;
		}
	}
	return level[ind];
}

double RegTask::searchLevel(int lv)const {
	for (size_t i = 0; i < n; i++)
	{
		if (level[i] == lv) return paid[i];
	}
	return 0.;
}
